#!/bin/sh
# Post-receive hook for Procurator CI
# This runs on the SERVER (bare repo), not the developer's machine

echo "=== Post-receive hook triggered ==="

# Available in bare repo environment:
# - GIT_DIR: Path to the bare repo (e.g., /srv/git/myrepo.git)
# - PWD: Same as GIT_DIR for post-receive
# - USER: SSH service account (usually "git"), NOT the developer

# Get repo path and name
# Use absolute path to avoid issues with relative paths
REPO_PATH="$(cd "${GIT_DIR:-.}" && pwd)"
BARE_REPO_NAME=$(basename "$REPO_PATH" .git)

# Derive working directory name by removing "Bare" suffix if present
# dummyBare -> dummy, or just use the name as-is
if echo "$BARE_REPO_NAME" | grep -q "Bare$"; then
    REPO_NAME="${BARE_REPO_NAME%Bare}"
else
    REPO_NAME="$BARE_REPO_NAME"
fi

# Construct path to working directory (sibling to bare repo)
PARENT_DIR=$(dirname "$REPO_PATH")
WORK_DIR="$PARENT_DIR/$REPO_NAME"

# Note: $USER is the SSH service account, not the actual developer
# For real identity, you'd need SSH key mapping or git config
SSH_USER="${USER:-unknown}"

echo "Repository: $REPO_NAME"
echo "Bare repo path: $REPO_PATH"
echo "Working directory: $WORK_DIR"
echo "SSH user: $SSH_USER"

while read oldrev newrev refname; do
    echo ""
    echo "--- Processing ref: $refname ---"
    echo "Old commit: ${oldrev:0:8}...${oldrev:32:40}"
    echo "New commit: ${newrev:0:8}...${newrev:32:40}"

    # Extract branch name from refs/heads/main -> main
    branch="${refname#refs/heads/}"

    # Check if this is a branch delete (newrev is all zeros)
    if [ "$newrev" = "0000000000000000000000000000000000000000" ]; then
        echo "âš ï¸  Branch deleted, skipping CI"
        continue
    fi

    # Check if this is a new branch (oldrev is all zeros)
    if [ "$oldrev" = "0000000000000000000000000000000000000000" ]; then
        echo "ðŸ†• New branch created"
    fi

    # Get commit info
    commit_author=$(git --git-dir="$REPO_PATH" log -1 --format="%an" "$newrev" 2>/dev/null || echo "unknown")
    commit_email=$(git --git-dir="$REPO_PATH" log -1 --format="%ae" "$newrev" 2>/dev/null || echo "")
    commit_message=$(git --git-dir="$REPO_PATH" log -1 --format="%s" "$newrev" 2>/dev/null || echo "")
    commit_count=$(git --git-dir="$REPO_PATH" rev-list --count "$oldrev..$newrev" 2>/dev/null || echo "1")

    # Get GPG signature verification if commit is signed
    gpg_status=$(git --git-dir="$REPO_PATH" log -1 --format="%G?" "$newrev" 2>/dev/null || echo "N")
    gpg_key=$(git --git-dir="$REPO_PATH" log -1 --format="%GK" "$newrev" 2>/dev/null || echo "")
    gpg_signer=$(git --git-dir="$REPO_PATH" log -1 --format="%GS" "$newrev" 2>/dev/null || echo "")

    # Map GPG status codes:
    # G = Good signature
    # B = Bad signature
    # U = Good signature, unknown validity
    # X = Good signature, expired
    # Y = Good signature, expired key
    # R = Good signature, revoked key
    # E = Cannot be checked (missing key)
    # N = No signature

    echo "Author: $commit_author <$commit_email>"
    echo "Message: $commit_message"
    echo "Commits pushed: $commit_count"
    echo "GPG Status: $gpg_status"
    [ -n "$gpg_signer" ] && echo "GPG Signer: $gpg_signer"

    # Notify CI service with all the info
    # Send bare repo path so CI can access it directly
    curl -s -X POST http://localhost:3000/api/builds \
        -H "Content-Type: application/json" \
        -d "{
            \"repo\":\"$REPO_NAME\",
            \"bare_repo_path\":\"$REPO_PATH\",
            \"old_rev\":\"$oldrev\",
            \"new_rev\":\"$newrev\",
            \"ref\":\"$refname\",
            \"commit_author\":\"$commit_author\",
            \"commit_email\":\"$commit_email\",
            \"commit_message\":\"$commit_message\",
            \"gpg_status\":\"$gpg_status\",
            \"gpg_key\":\"$gpg_key\",
            \"gpg_signer\":\"$gpg_signer\",
            \"pusher\":\"$SSH_USER\"
        }" \
        && echo "âœ“ CI notified successfully" \
        || echo "âœ— CI notification failed"
done

echo ""
echo "==================================="
